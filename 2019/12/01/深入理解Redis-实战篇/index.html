<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hello,word!">










<meta name="description" content="Redis客户端客户端通信原理客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。 客户端和服务器发送的命令或数据一律以 \r\n (CRLF 回车+换行)结尾。如果使用 wireshark 对 jedis 抓包:环境:Jedis 连接到虚拟机 202，运行 main，对 VMnet8 抓包。过滤条件:ip.dst==192.168.8.202 and tcp.po">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Redis-实战篇">
<meta property="og:url" content="http://magicj.top/2019/12/01/深入理解Redis-实战篇/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="Redis客户端客户端通信原理客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。 客户端和服务器发送的命令或数据一律以 \r\n (CRLF 回车+换行)结尾。如果使用 wireshark 对 jedis 抓包:环境:Jedis 连接到虚拟机 202，运行 main，对 VMnet8 抓包。过滤条件:ip.dst==192.168.8.202 and tcp.po">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://magicj.top/images/20191130/1.png">
<meta property="og:image" content="http://magicj.top/images/20191130/2.png">
<meta property="og:image" content="http://magicj.top/images/20191130/3.png">
<meta property="og:image" content="http://magicj.top/images/20191130/4.png">
<meta property="og:image" content="http://magicj.top/images/20191130/5.png">
<meta property="og:updated_time" content="2019-12-01T07:59:46.005Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Redis-实战篇">
<meta name="twitter:description" content="Redis客户端客户端通信原理客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。 客户端和服务器发送的命令或数据一律以 \r\n (CRLF 回车+换行)结尾。如果使用 wireshark 对 jedis 抓包:环境:Jedis 连接到虚拟机 202，运行 main，对 VMnet8 抓包。过滤条件:ip.dst==192.168.8.202 and tcp.po">
<meta name="twitter:image" content="http://magicj.top/images/20191130/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://magicj.top/2019/12/01/深入理解Redis-实战篇/">





  <title>深入理解Redis-实战篇 | 技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://magicj.top/2019/12/01/深入理解Redis-实战篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Jun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Redis-实战篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-01T15:46:00+08:00">
                2019-12-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-01T15:59:46+08:00">
                2019-12-01
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/01/深入理解Redis-实战篇/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2019/12/01/深入理解Redis-实战篇/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><h3 id="客户端通信原理"><a href="#客户端通信原理" class="headerlink" title="客户端通信原理"></a>客户端通信原理</h3><p>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。 客户端和服务器发送的命令或数据一律以 \r\n (CRLF 回车+换行)结尾。<br>如果使用 wireshark 对 jedis 抓包:<br>环境:Jedis 连接到虚拟机 202，运行 main，对 VMnet8 抓包。<br>过滤条件:ip.dst==192.168.8.202 and tcp.port in {6379}<br>对 set test 111 抓包，可以看到实际发出的数据包是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$4\r\ntest\r\n$3\r\n111\r\n</span><br></pre></td></tr></table></figure>

<p>对 get test 抓包，可以看到实际发出的数据包是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*2\r\n$3\r\nGET\r\n$4\r\ntest\r\n</span><br></pre></td></tr></table></figure>

<p>客户端跟 Redis 之间 使用一种特殊的编码格式(在 AOF 文件里面我们看到了)，叫 做 Redis Serialization Protocol (Redis 序列化协议)。特点:容易实现、解析快、可读 性强。客户端发给服务端的消息需要经过编码，服务端收到之后会按约定进行解码，反之亦然。<br>基于此，我们可以自己实现一个 Redis 客户端。</p>
<ol>
<li>建立 Socket 连接</li>
<li>OutputStream 写入数据(发送到服务端) </li>
<li>InputStream 读取数据(从服务端接口)</li>
</ol>
<p>基于这种协议，我们可以用 Java 实现所有的 Redis 操作命令。当然，我们不需要这 么做，因为已经有很多比较成熟的 Java 客户端，实现了完整的功能和高级特性，并且提供了良好的性能。<br><a href="https://redis.io/clients#java" target="_blank" rel="noopener">官网展示的客户端</a><br>官网推荐的 Java 客户端有 3 个 Jedis，Redisson 和 Luttuce。</p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Jedis</td>
<td>A blazingly small and sane redis java client</td>
</tr>
<tr>
<td>lettuce</td>
<td>Advanced Redis client for thread-safe sync, async, and reactive usage. Supports Cluster, Sentinel, Pipelining, and codecs.</td>
</tr>
<tr>
<td>Redisson</td>
<td>distributed and scalable Java data structures on top of Redis server</td>
</tr>
</tbody></table>
<p>Spring 连接 Redis 用的是什么?RedisConnectionFactory 接口支持多种实现，例如 : JedisConnectionFactory 、 JredisConnectionFactory、LettuceConnectionFactory、SrpConnectionFactory。</p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>Jedis 是我们最熟悉和最常用的客户端。轻量，简洁，便于集成和改造。<br>Jedis 多个线程使用一个连接的时候线程不安全。可以使用连接池，为每个请求创建不同的连接，基于 Apache common pool 实现。跟数据库一样，可以设置最大连接数等参数。Jedis 中有多种连接池的子类（JedisPool、JedisSentinelPool、ShardedJedisPool）。<br>Jedis 有4种工作模式:单节点、分片、哨兵、集群。<br>Jedis 有3种请求模式:Client、Pipeline、事务。Client 模式就是客户端发送一个命令，阻塞等待服务端执行，然后读取 返回结果。Pipeline 模式是一次性发送多个命令，最后一次取回所有的返回结果，这种模式通过减少网络的往返时间和 io 读写次数，大幅度提高通信性能。第三种是事务模式。Transaction 模式即开启 Redis 的事务管理，事务模式开启后，所有的命令(除了 exec，discard，multi 和 watch)到达服务端以后不会立即执行，会进入一个等待队列。</p>
<h4 id="Sentinel-获取连接原理"><a href="#Sentinel-获取连接原理" class="headerlink" title="Sentinel 获取连接原理"></a>Sentinel 获取连接原理</h4><p>问题:Jedis 连接 Sentinel 的时候，我们配置的是全部哨兵的地址。Sentinel 是如 何返回可用的 master 地址的呢?<br>在构造方法中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = new JedisSentinelPool(masterName, sentinels);</span><br></pre></td></tr></table></figure>

<p>调用了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostAndPort master = initSentinels(sentinels, masterName);</span><br></pre></td></tr></table></figure>

<p>查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private HostAndPort initSentinels(Set&lt;String&gt; sentinels, final String masterName) &#123; </span><br><span class="line">    HostAndPort master = null;</span><br><span class="line">    boolean sentinelAvailable = false; </span><br><span class="line">    log.info(&quot;Trying to find master from available Sentinels...&quot;);</span><br><span class="line">    // 有多个 sentinels,遍历这些个 sentinels</span><br><span class="line">    for (String sentinel : sentinels) &#123;</span><br><span class="line">        // host:port 表示的 sentinel 地址转化为一个 HostAndPort 对象。</span><br><span class="line">        final HostAndPort hap = HostAndPort.parseString(sentinel); </span><br><span class="line">        log.fine(&quot;Connecting to Sentinel &quot; + hap); </span><br><span class="line">        Jedis jedis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 连接到 sentinel</span><br><span class="line">            jedis = new Jedis(hap.getHost(), hap.getPort());</span><br><span class="line">            // 根据 masterName 得到 master 的地址，返回一个 list，host= list[0], port =// list[1]</span><br><span class="line">            List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);</span><br><span class="line"></span><br><span class="line">            sentinelAvailable = true; </span><br><span class="line">            if (masterAddr == null || masterAddr.size() != 2) &#123;</span><br><span class="line">                log.warning(&quot;Can not get master addr, master name: &quot; + masterName + &quot;. Sentinel: &quot; + hap</span><br><span class="line">                        + &quot;.&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果在任何一个 sentinel 中找到了 master，不再遍历 sentinels master = toHostAndPort(masterAddr);</span><br><span class="line">            log.fine(&quot;Found Redis master at &quot; + master);</span><br><span class="line">            break;</span><br><span class="line">        &#125; catch (JedisException e) &#123;</span><br><span class="line">            // resolves #1036, it should handle JedisException there&apos;s another chance</span><br><span class="line">            // of raising JedisDataException</span><br><span class="line">            log.warning(&quot;Cannot get master address from sentinel running @ &quot; + hap + &quot;. Reason: &quot; + e</span><br><span class="line">                    + &quot;. Trying next one.&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (jedis != null) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 到这里，如果 master 为 null，则说明有两种情况，一种是所有的 sentinels 节点都 down 掉了，一种是 master 节点没有被存活的 sentinels 监控到</span><br><span class="line">    if (master == null) &#123;</span><br><span class="line">        if (sentinelAvailable) &#123;</span><br><span class="line">            // can connect to sentinel, but master name seems to not</span><br><span class="line">            // monitored</span><br><span class="line">            throw new JedisException(&quot;Can connect to sentinel, but &quot; + masterName</span><br><span class="line">                    + &quot; seems to be not monitored...&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new JedisConnectionException(&quot;All sentinels down, cannot determine where is &quot; + masterName + &quot; master is running...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果走到这里，说明找到了 master 的地址</span><br><span class="line">    log.info(&quot;Redis master running at &quot; + master + &quot;, starting Sentinel listeners...&quot;);</span><br><span class="line">    // 启动对每个 sentinels 的监听为每个 sentinel 都启动了一个监听者 MasterListener。MasterListener 本身是一个线程，它会去订阅 sentinel 上关于 master 节点地址改变的消息。</span><br><span class="line">    for (String sentinel : sentinels) &#123;</span><br><span class="line">        final HostAndPort hap = HostAndPort.parseString(sentinel);</span><br><span class="line">        MasterListener masterListener = new MasterListener(masterName, hap.getHost(), hap.getPort());</span><br><span class="line">        // whether MasterListener threads are alive or not, process can be stopped masterListener.setDaemon(true);</span><br><span class="line">        masterListeners.add(masterListener);</span><br><span class="line">        masterListener.start();</span><br><span class="line">    &#125; </span><br><span class="line">    return master;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cluster-获取连接原理"><a href="#Cluster-获取连接原理" class="headerlink" title="Cluster 获取连接原理"></a>Cluster 获取连接原理</h4><p>问题:使用 Jedis 连接 Cluster 的时候，我们只需要连接到任意一个或者多个 redis group 中的实例地址，那我们是怎么获取到需要操作的 Redis Master 实例的?<br>关键问题:在于如何存储 slot 和 Redis 连接池的关系。</p>
<ol>
<li><p>程序启动初始化集群环境，读取配置文件中的节点配置，无论是主从，无论多少个，只拿第一个，获取 redis 连接实例(后面有个 break)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// redis.clients.jedis.JedisClusterConnectionHandler#initializeSlotsCache</span><br><span class="line">private void initializeSlotsCache(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolConfig, String password) &#123;</span><br><span class="line">    for (HostAndPort hostAndPort : startNodes) &#123;</span><br><span class="line">        // 获取一个 Jedis 实例</span><br><span class="line">        Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort());</span><br><span class="line">        if (password != null) &#123;</span><br><span class="line">            jedis.auth(password);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取 Redis 节点和 Slot 虚拟槽 cache.discoverClusterNodesAndSlots(jedis); // 直接跳出循环</span><br><span class="line">            break;</span><br><span class="line">        &#125; catch (JedisConnectionException e) &#123; // try next nodes</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (jedis != null) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用获取的 redis 连接实例执行 clusterSlots ()方法，实际执行 redis 服务端 cluster slots 命令，获取虚拟槽信息。<br>该集合的基本信息为[long, long, List, List], 第一，二个元素是该节点负责槽点的起 始位置，第三个元素是主节点信息，第四个元素为主节点对应的从节点信息。该 list 的 基本信息为[string,int,string],第一个为 host 信息，第二个为 port 信息，第三个为唯一 id。</p>
</li>
<li><p>获取有关节点的槽点信息后，调用 getAssignedSlotArray(slotinfo)来获取所有<br>的槽点值。</p>
</li>
<li><p>再获取主节点的地址信息，调用 generateHostAndPort(hostInfo)方法，生成一<br>个 ostAndPort 对象。</p>
</li>
<li><p>再根据节点地址信息来设置节点对应的 JedisPool，即设置 Map&lt;String,JedisPool&gt; nodes 的值。<br>接下来判断若此时节点信息为主节点信息时，则调用 assignSlotsToNodes 方法，设置每个槽点值对应的连接池，即设置 Map&lt;Integer, JedisPool&gt; slots 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// redis.clients.jedis.JedisClusterInfoCache#discoverClusterNodesAndSlots</span><br><span class="line">public void discoverClusterNodesAndSlots(Jedis jedis) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">​</span><br><span class="line">    try &#123;</span><br><span class="line">        reset();</span><br><span class="line">        // 获取节点集合</span><br><span class="line">        List&lt;Object&gt; slots = jedis.clusterSlots(); // 遍历3个master节点</span><br><span class="line">        for (Object slotInfoObj : slots) &#123;</span><br><span class="line">            // slotInfo 槽开始，槽结束，主，从</span><br><span class="line">            // &#123;[0,5460,7291,7294],[5461,10922,7292,7295],[10923,16383,7293,7296]&#125;</span><br><span class="line">            List&lt;Object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;</span><br><span class="line">            // 如果&lt;=2，代表没有分配 slot</span><br><span class="line">            if (slotInfo.size() &lt;= MASTER_NODE_INDEX) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取分配到当前 master 节点的数据槽，例如 7291 节点的&#123;0,1,2,3......5460&#125;</span><br><span class="line">            List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo); ​</span><br><span class="line">            // hostInfos</span><br><span class="line">            int size = slotInfo.size();// size 是 4，槽最小最大，主，从</span><br><span class="line">            // 第 3 位和第 4 位是主从端口的信息</span><br><span class="line">            for (int i = MASTER_NODE_INDEX; i &lt; size; i++) &#123;</span><br><span class="line">                List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);</span><br><span class="line">                if (hostInfos.size() &lt;= 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 根据 IP 端口生成 HostAndPort 实例</span><br><span class="line">                HostAndPort targetNode = generateHostAndPort(hostInfos);</span><br><span class="line">                // 据HostAndPort解析出ip:port的key值，再根据key从缓存中查询对应的jedisPool实例。如果没有jedisPool实例，就创建 JedisPool 实例，最后放入缓存中。nodeKey 和 nodePool 的关系 </span><br><span class="line">                setupNodeIfNotExist(targetNode);</span><br><span class="line">                // 把 slot 和 jedisPool 缓存起来(16384 个)，key 是 slot 下标，value 是连接池 </span><br><span class="line">                if (i == MASTER_NODE_INDEX) &#123;</span><br><span class="line">                    assignSlotsToNode(slotNums, targetNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>从集群环境存取值:</p>
<ol>
<li>把 key 作为参数，执行 CRC16 算法，获取 key 对应的 slot 值。 </li>
<li>通过该 slot 值，去 slots 的 map 集合中获取 jedisPool 实例。</li>
<li>通过 jedisPool 实例获取 jedis 实例，最终完成 redis 数据存取工作。</li>
</ol>
<h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>通过 Lua 脚本 set 2 万个 key 用了好几分钟，这个速度太慢了，完全没有把 Redis 10 万的 QPS 利用起来。但是单个命令的执行到底慢在哪里?</p>
<h5 id="慢在哪里"><a href="#慢在哪里" class="headerlink" title="慢在哪里?"></a>慢在哪里?</h5><p>Redis 使用的是客户端/服务器(C/S)模型和请求/响应协议的 TCP 服务器。这意味着通常情况下一个请求会遵循以下步骤:</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<p>Redis 客户端与 Redis 服务器之间使用 TCP 协议进行连接，一个客户端可以通过一个 socket 连接发起多个请求命令。每个请求命令发出后 client 通常会阻塞并等待 redis 服务器处理，redis 处理完请求命令后会将结果通过响应报文返回给 client，因此当执行多条命令的时候都需要等待上一条命令执行完毕才能执行。<br>Redis 本身提供了一些批量操作命令，比如 mget，mset，可以减少通信的时间，但是大部分命令是不支持 multi 操作的，例如 hash 就没有。<br>由于通信会有网络延迟，假如 client 和 server 之间的包传输时间需要 10 毫秒，一次交互就是 20 毫秒(RTT:Round Trip Time)。这样的话，client 1 秒钟也只能也只能发送 50 个命令。这显然没有充分利用 Redis 的处理能力。另外一个，Redis 服务端执行 I/O 的次数过多。</p>
<h5 id="Pipeline-管道"><a href="#Pipeline-管道" class="headerlink" title="Pipeline 管道"></a>Pipeline 管道</h5><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener">https://redis.io/topics/pipelining</a><br>那我们能不能像数据库的 batch 操作一样，把一组命令组装在一起发送给 Redis 服务端执行，然后一次性获得返回结果呢?这个就是 Pipeline 的作用。Pipeline 通过一个队列把所有的命令缓存起来，然后把多个命令在一次连接中发送给服务器。<br><img src="/images/20191130/1.png" alt><br>要实现 Pipeline，既要服务端的支持，也要客户端的支持。对于服务端来说，需要能够处理客户端通过一个 TCP 连接发来的多个命令，并且逐个地执行命令一起返回 。<br>对于客户端来说，要把多个命令缓存起来，达到一定的条件就发送出去，最后才处理 Redis 的应答(这里也要注意对客户端内存的消耗)。<br>jedis-pipeline 的 client-buffer 限制:8192bytes，客户端堆积的命令超过 8192bytes 时，会发送给服务端。<br>源码:redis.clients.util.RedisOutputStream.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public RedisOutputStream(final OutputStream out) &#123; </span><br><span class="line">    this(out, 8192);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pipeline 对于命令条数没有限制，但是命令可能会受限于 TCP 包大小。<br>如果 Jedis 发送了一组命令，而发送请求还没有结束，Redis 响应的结果会放在接收缓冲区。如果接收缓冲区满了，jedis 会通知 redis win=0，此时 redis 不会再发送结果给 jedis 端，转而把响应结果保存在 Redis 服务端的输出缓冲区中。<br>输出缓冲区的配置:redis.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>配置</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>客户端类型，分为三种。a)normal:普通客户端;b)slave:slave 客户端，用于复制;c) pubsub:发布订阅客户端</td>
</tr>
<tr>
<td>hard limit</td>
<td>如果客户端使用的输出缓冲区大于<hard limit>，客户端会被立即关闭，0 代表不限制</hard></td>
</tr>
<tr>
<td>soft limit <br>soft seconds</td>
<td>如果客户端使用的输出缓冲区超过了<soft limit>并且持续了<soft limit>秒，客户端会被立即 关闭</soft></soft></td>
</tr>
</tbody></table>
<p>每个客户端使用的输出缓冲区的大小可以用 client list 命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; client list</span><br><span class="line">id=5 addr=192.168.8.1:10859 fd=8 name= age=5 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=5 qbuf-free=32763 obl=16380 oll=227 omem=4654408 events=rw cmd=set</span><br></pre></td></tr></table></figure>

<ul>
<li>obl : 输出缓冲区的长度(字节为单位， 0 表示没有分配输出缓冲区)</li>
<li>oll : 输出列表包含的对象数量(当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个</li>
<li>队列里)</li>
<li>omem : 输出缓冲区和输出列表占用的内存总量</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>如果某些操作需要马上得到 Redis 操作是否成功的结果，这种场景就不适合。<br>有些场景，例如批量写入数据，对于结果的实时性和成功性要求不高，就可以用 Pipeline。</p>
<h4 id="Jedis-实现分布式锁"><a href="#Jedis-实现分布式锁" class="headerlink" title="Jedis 实现分布式锁"></a>Jedis 实现分布式锁</h4><p>原文地址:<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a><br>中文地址:<a href="http://redis.cn/topics/distlock.html" target="_blank" rel="noopener">http://redis.cn/topics/distlock.html</a><br>分布式锁的基本特性或者要求:</p>
<ol>
<li>互斥性:只有一个客户端能够持有锁。</li>
<li>不会产生死锁:即使持有锁的客户端崩溃，也能保证后续其他客户端可以获取锁。</li>
<li>只有持有这把锁的客户端才能解锁。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line">    // set 支持多个参数 NX(not exist) XX(exist) EX(seconds) PX(million seconds)</span><br><span class="line">    String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">    if (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数解读:</p>
<ul>
<li>lockKey 是 Redis key 的名称，也就是谁添加成功这个 key 代表谁获取锁成功。</li>
<li>requestId 是客户端的 ID(设置成 value)，如果我们要保证只有加锁的客户端才能释放锁，就必须获得客户端的 ID(保证第 3 点)。</li>
<li>SET_IF_NOT_EXIST 是我们的命令里面加上 NX(保证第 1 点)。 </li>
<li>SET_WITH_EXPIRE_TIME，PX 代表以毫秒为单位设置 key 的过期时间(保证第 2 点)。expireTime 是自动释放锁的时间，比如 5000 代表 5 秒。</li>
</ul>
<p>释放锁，直接删除 key 来释放锁可以吗?就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongReleaseLock1(Jedis jedis, String lockKey) &#123; </span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有对客户端 requestId 进行判断，可能会释放其他客户端持有的锁。 先判断后删除呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) &#123; </span><br><span class="line">    // 判断加锁与解锁是不是同一个客户端</span><br><span class="line">    if (requestId.equals(jedis.get(lockKey))) &#123;</span><br><span class="line">        // 若在此时，这把锁突然不是这个客户端的，则会误解锁</span><br><span class="line">        jedis.del(lockKey); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在释放锁的时候，这把锁已经不属于这个客户端(例如已经过期，并且被别的客户端获取锁成功了)，那就会出现释放了其他客户端的锁的情况。<br>所以我们把判断客户端是否相等和删除 key 的操作放在 Lua 脚本里面执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123;</span><br><span class="line">    String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    if (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是 Jedis 里面分布式锁的实现。</p>
<h3 id="Luttece"><a href="#Luttece" class="headerlink" title="Luttece"></a>Luttece</h3><p><a href="https://lettuce.io/" target="_blank" rel="noopener">https://lettuce.io/</a></p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>与 Jedis 相比，Lettuce 则完全克服了其线程不安全的缺点:Lettuce 是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式(Reactive)。多个线程可以共享一个连接实例，而不必担心多线程并发问题。<br>它基于 Netty 框架构建，支持 Redis 的高级功能，如 Pipeline、发布订阅/事务、 Sentinel、集群、支持连接池。<br>Lettuce 是 Spring Boot 2.x 默认的客户端，替换了 Jedis。集成之后我们不需要单独使用它，直接调用 Spring 的 RedisTemplate 操作，连接和创建和关闭也不需要我们操心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;                               </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p><a href="https://redisson.org/" target="_blank" rel="noopener">https://redisson.org/</a><br><a href="https://github.com/redisson/redisson/wiki/目录" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/目录</a></p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格(In-Memory Data Grid)，提供了分布式和可扩展的 Java 数据结构。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>基于 Netty 实现，采用非阻塞 IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池、pipeline、LUA Scripting、Redis Sentinel、Redis Cluster </li>
<li>不支持事务，官方建议以 LUA Scripting 代替事务 </li>
<li>主从、哨兵、集群都支持。Spring 也可以配置和注入 RedissonClient。</li>
</ul>
<h4 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h4><p>在 Redisson 里面提供了更加简单的分布式锁的实现。<br><img src="/images/20191130/2.png" alt><br>加锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    RLock rLock = redissonClient.getLock(&quot;updateAccount&quot;);</span><br><span class="line">    // 最多等待 100 秒、上锁 10s 以后自动解锁 </span><br><span class="line">    if (rLock.tryLock(100, 10, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        System.out.println(&quot;获取锁成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // do something</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获得 RLock 之后，只需要一个 tryLock 方法，里面有 3 个参数:</p>
<ol>
<li>watiTime:获取锁的最大等待时间，超过这个时间不再尝试获取锁 </li>
<li>leaseTime:如果没有调用 unlock，超过了这个时间会自动释放锁 </li>
<li>TimeUnit:释放时间的单位</li>
</ol>
<p><strong>Redisson 的分布式锁是怎么实现的呢?</strong><br>在加锁的时候，在 Redis 写入了一个 HASH，key 是锁名称，field 是线程名称，value 是 1(表示锁的重入次数)。<br>源码路径：tryLock()——tryAcquire()——tryAcquireAsync()——tryLockInnerAsync()<br>最终也是调用了一段 Lua 脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// KEYS[1] 锁名称 updateAccount </span><br><span class="line">// ARGV[1] key 过期时间 10000ms </span><br><span class="line">// ARGV[2] 线程名称</span><br><span class="line">// 锁名称不存在</span><br><span class="line">if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then</span><br><span class="line">    // 创建一个 hash，key=锁名称，field=线程名，value=1 </span><br><span class="line">    redis.call(&apos;hset&apos;, KEYS[1], ARGV[2], 1);</span><br><span class="line">    // 设置 hash 的过期时间</span><br><span class="line">    redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]);</span><br><span class="line">    return nil;</span><br><span class="line">end;</span><br><span class="line">// 锁名称存在，判断是否当前线程持有的锁</span><br><span class="line">if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[2]) == 1) then</span><br><span class="line">    // 如果是，value+1，代表重入次数+1</span><br><span class="line">    redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[2], 1);</span><br><span class="line">    // 重新获得锁，需要重新设置 Key 的过期时间 </span><br><span class="line">    redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]);</span><br><span class="line">    return nil;</span><br><span class="line">end;</span><br><span class="line">// 锁存在，但是不是当前线程持有，返回过期时间(毫秒) </span><br><span class="line">return redis.call(&apos;pttl&apos;, KEYS[1]);</span><br></pre></td></tr></table></figure>

<p>释放锁，源码:unlock——unlockInnerAsync</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// KEYS[1] 锁的名称 updateAccount</span><br><span class="line">// KEYS[2] 频道名称 redisson_lock__channel:&#123;updateAccount&#125; </span><br><span class="line">// ARGV[1] 释放锁的消息 0</span><br><span class="line">// ARGV[2] 锁释放时间 10000</span><br><span class="line">// ARGV[3] 线程名称</span><br><span class="line">// 锁不存在(过期或者已经释放了)</span><br><span class="line">if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then</span><br><span class="line">    // 发布锁已经释放的消息 </span><br><span class="line">    redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); </span><br><span class="line">    return 1;</span><br><span class="line">end;</span><br><span class="line">// 锁存在，但是不是当前线程加的锁</span><br><span class="line">if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[3]) == 0) then</span><br><span class="line">    return nil; </span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">// 锁存在，是当前线程加的锁</span><br><span class="line">// 重入次数-1</span><br><span class="line">local counter = redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[3], -1);</span><br><span class="line">// -1 后大于 0，说明这个线程持有这把锁还有其他的任务需要执行 </span><br><span class="line">if (counter &gt; 0) then</span><br><span class="line">    // 重新设置锁的过期时间 </span><br><span class="line">    redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]); return 0;</span><br><span class="line">else</span><br><span class="line">    // -1 之后等于 0，现在可以删除锁了 </span><br><span class="line">    redis.call(&apos;del&apos;, KEYS[1]);</span><br><span class="line">    // 删除之后发布释放锁的消息 </span><br><span class="line">    redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); return 1;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">// 其他情况返回 nil </span><br><span class="line">return nil;</span><br></pre></td></tr></table></figure>

<p>这个是 Redisson 里面分布式锁的实现，我们在调用的时候非常简单。<br>Redisson 跟 Jedis 定位不同，它不是一个单纯的 Redis 客户端，而是基于 Redis 实现的分布式的服务，如果有需要用到一些分布式的数据结构，比如我们还可以基于 Redisson 的分布式队列实现分布式事务，就可以引入 Redisson 的依赖实现。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><h3 id="缓存使用场景"><a href="#缓存使用场景" class="headerlink" title="缓存使用场景"></a>缓存使用场景</h3><p>针对读多写少的高并发场景，我们可以使用缓存来提升查询速度。<br>当我们使用 Redis 作为缓存的时候，一般流程是这样的:<br>1、如果数据在 Redis 存在，应用就可以直接从 Redis 拿到数据，不用访问数据库。<br><img src="/images/20191130/3.png" alt><br>2、如果 Redis 里面没有，先到数据库查询，然后写入到 Redis，再返回给应用。<br><img src="/images/20191130/4.png" alt></p>
<h3 id="一致性问题的定义"><a href="#一致性问题的定义" class="headerlink" title="一致性问题的定义"></a>一致性问题的定义</h3><p>因为这些数据是很少修改的，所以在绝大部分的情况下可以命中缓存。但是，一旦 被缓存的数据发生变化的时候，我们既要操作数据库的数据，也要操作 Redis 的数据， 所以问题来了。现在我们有两种选择:</p>
<ol>
<li>先操作 Redis 的数据再操作数据库的数据</li>
<li>先操作数据库的数据再操作 Redis 的数据</li>
</ol>
<p>首先需要明确的是，不管选择哪一种方案， 我们肯定是希望两个操作要么都成功，要么都一个都不成功。不然就会发生 Redis 跟数据库的数据不一致的问题。<br>但是，Redis 的数据和数据库的数据是不可能通过事务达到统一的，我们只能根据相应的场景和所需要付出的代价来采取一些措施降低数据不一致的问题出现的概率，在数据一致性和性能之间取得一个权衡。<br>对于数据库的实时性一致性要求不是特别高的场合，比如 T+1 的报表，可以采用定时任务查询数据库数据同步到 Redis 的方案。<br>由于我们是以数据库的数据为准的，所以给缓存设置一个过期时间，是保证最终一致性的解决方案。</p>
<h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><h4 id="Redis-删除还是更新"><a href="#Redis-删除还是更新" class="headerlink" title="Redis:删除还是更新?"></a>Redis:删除还是更新?</h4><p>这里我们先要补充一点，当存储的数据发生变化，Redis 的数据也要更新的时候，我们有两种方案，一种就是直接更新，调用 set;还有一种是直接删除缓存，让应用在下次查询的时候重新写入。<br>这两种方案怎么选择呢?这里我们主要考虑更新缓存的代价。<br>更新缓存之前，是不是要经过其他表的查询、接口调用、计算才能得到最新的数据， 而不是直接从数据库拿到的值。如果是的话，建议直接删除缓存，这种方案更加简单， 而且避免了数据库的数据和缓存不一致的情况。在一般情况下，我们也推荐使用删除的方案。</p>
<h4 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h4><p>正常情况:</p>
<ul>
<li>更新数据库，成功。</li>
<li>删除缓存，成功。</li>
</ul>
<p>异常情况:</p>
<ul>
<li>更新数据库失败，程序捕获异常，不会走到下一步，所以数据不会出现不一致。 </li>
<li>更新数据库成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一致的情况。</li>
</ul>
<p>这种问题怎么解决呢?我们可以提供一个重试的机制。<br>比如:如果删除缓存失败，我们捕获这个异常，把需要删除的 key 发送到消息队列。 让后自己创建一个消费者消费，尝试再次删除这个 key。<br>这种方式有个缺点，会对业务代码造成入侵。<br>所以我们又有了第二种方案(异步更新缓存):<br>因为更新数据库时会往 binlog 写入日志，所以我们可以通过一个服务来监听 binlog 的变化(比如阿里的 canal)，然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。<br>总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。无论是重试还是异步删除，都是最终一致性的思想。</p>
<h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h4><p>正常情况:</p>
<ul>
<li>删除缓存，成功。</li>
<li>更新数据库，成功。</li>
</ul>
<p>异常情况:</p>
<ul>
<li>删除缓存，程序捕获异常，不会走到下一步，所以数据不会出现不一致。 </li>
<li>删除缓存成功，更新数据库失败。 因为以数据库的数据为准，所以不存在数据不一致的情况。</li>
</ul>
<p>看起来好像没问题，但是如果有程序并发操作的情况下:</p>
<ol>
<li>线程 A 需要更新数据，首先删除了 Redis 缓存</li>
<li>线程 B 查询数据，发现缓存不存在，到数据库查询旧值，写入 Redis，返回 </li>
<li>线程 A 更新了数据库</li>
</ol>
<p>这个时候，Redis 是旧的值，数据库是新的值，发生了数据不一致的情况。<br>那问题就变成了:能不能让对同一条数据的访问串行化呢?代码肯定保证不了，因为有多个线程，即使做了任务队列也可能有多个服务实例。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作是串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是这种情况吞吐量 太低了。<br>所以我们有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p>
<ol>
<li>删除缓存</li>
<li>更新数据库</li>
<li>休眠 500ms(这个时间，依据读取数据的耗时而定)</li>
<li>再次删除缓存</li>
</ol>
<h2 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h2><p>在 Redis 存储的所有数据中，有一部分是被频繁访问的。有两种情况可能会导致热点问题的产生，一个是用户集中访问的数据，比如抢购的商品，明星结婚和明星出轨的微博。还有一种就是在数据进行分片的情况下，负载不均衡，超过了单个服务器的承受能力。热点问题可能引起缓存服务的不可用，最终造成压力堆积到数据库。<br>出于存储和流量优化的角度，我们必须要找到这些热点数据。</p>
<h3 id="热点数据发现"><a href="#热点数据发现" class="headerlink" title="热点数据发现"></a>热点数据发现</h3><p>除了自动的缓存淘汰机制之外，怎么找出那些访问频率高的 key 呢?或者说，我们可以在哪里记录 key 被访问的情况呢?</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>第一个当然是在客户端了，比如我们可不可以在所有调用了 get、set 方法的地方，加上 key 的计数。但是这样的话，每一个地方都要修改，重复的代码也多。如果我们用的是 Jedis 的客户端，我们可以在 Jedis 的 Connection 类的 sendCommand()里面，用 一个 HashMap 进行 key 的计数。<br>但是这种方式有几个问题:</p>
<ol>
<li>不知道要存多少个 key，可能会发生内存泄露的问题。 </li>
<li>会对客户端的代码造成入侵。 </li>
<li>只能统计当前客户端的热点 key。</li>
</ol>
<h4 id="代理层"><a href="#代理层" class="headerlink" title="代理层"></a>代理层</h4><p>第二种方式就是在代理端实现，比如 TwemProxy 或者 Codis，但是不是所有的项目都使用了代理的架构。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>第三种就是在服务端统计，Redis 有一个 monitor 的命令，可以监控到所有 Redis 执行的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jedis.monitor(new JedisMonitor() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCommand(String command) &#123;</span><br><span class="line">        System.out.println(&quot;#monitor: &quot; + command); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Facebook 的开源项目 <a href="https://github.com/facebookarchive/redis-faina.git" target="_blank" rel="noopener">redis-faina</a> 就是基于这个原理实现的。 它是一个 python 脚本，可以分析 monitor 的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 monitor | head -n 100000 | ./redis-faina.py</span><br></pre></td></tr></table></figure>

<p>这种方法也会有两个问题:</p>
<ol>
<li>monitor 命令在高并发的场景下，会影响性能，所以 不适合长时间使用。</li>
<li>只能统计一个 Redis 节点的热点 key。</li>
</ol>
<h4 id="机器层面"><a href="#机器层面" class="headerlink" title="机器层面"></a>机器层面</h4><p>还有一种方法就是机器层面的，通过对 TCP 协议进行抓包，也有一些开源的方案，比如 ELK 的 packetbeat 插件。<br>当我们发现了热点 key 之后，我们来看下热点数据在高并发的场景下可能会出现的问题，以及怎么去解决。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h4><p>缓存雪崩就是 Redis 的大量热点数据同时过期(失效)，因为设置了相同的过期时间，刚好这个时候 Redis 请求的并发量又很大，就会导致所有的请求落到数据库。</p>
<h4 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h4><ol>
<li>加互斥锁或者使用队列，针对同一个 key 只允许一个线程到数据库查询 </li>
<li>缓存定时预先更新，避免同时失效</li>
<li>通过加随机数，使 key 在不同的时间过期</li>
<li>缓存永不过期</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="缓存穿透何时发生"><a href="#缓存穿透何时发生" class="headerlink" title="缓存穿透何时发生"></a>缓存穿透何时发生</h4><p>我们已经知道了 Redis 使用的场景了。在缓存存在和缓存不存在的情况下的什么情况我们都了解了。<br><img src="/images/20191130/5.png" alt><br>还有一种情况，数据在数据库和 Redis 里面都不存在，可能是一次条件错误的查询。在这种情况下，因为数据库值不存在，所以肯定不会写入 Redis，那么下一次查询相同的 key 的时候，肯定还是会再到数据库查一次。那么这种循环查询数据库中不存在的值，并且每次使用的是相同的 key 的情况，我们有没有什么办法避免应用到数据库查询呢?</p>
<ol>
<li>缓存空数据 </li>
<li>缓存特殊字符串，比如&amp;&amp;</li>
</ol>
<p>我们可以在数据库缓存一个空字符串，或者缓存一个特殊的字符串，那么在应用里 面拿到这个特殊字符串的候，就知道数据库没有值了，也没有必要再到数据库查询了。<br>但是这里需要设置一个过期时间，不然的话数据库已经新增了这一条记录，应用也还是拿不到值。<br>这个是应用重复查询同一个不存在的值的情况，如果应用每一次查询的不存在的值是不一样的呢?即使你每次都缓存特殊字符串也没用，因为它的值不一样，比如我们的用户系统登录的场景，如果是恶意的请求，它每次都生成了一个符合 ID 规则的账号，但是这个账号在我们的数据库是不存在的，那 Redis 就完全失去了作用。<br>这种因为每次查询的值都不存在导致的 Redis 失效的情况，我们就把它叫做缓存穿透。这个问题我们应该怎么去解决呢?</p>
<h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><p>其实它也是一个通用的问题，关键就在于我们怎么知道请求的 key 在我们的数据库里面是否存在，如果数据量特别大的话，我们怎么去快速判断。<br>这也是一个非常经典的面试题:<br><strong>如何在海量元素中(例如 10 亿无序、不定长、不重复)快速判断一个元素是否存在?</strong><br>如果是缓存穿透的这个问题，我们要避免到数据库查询不存的数据，肯定要把这 10 亿放在别的地方。这些数据在 Redis 里面也是没有的，为了加快检索速度，我们要把数据放到内存里面来判断，问题来了:<br>如果我们直接把这些元素的值放到基本的数据结构(List、Map、Tree)里面，比如 一个元素 1 字节的字段，10 亿的数据大概需要 900G 的内存空间，这个对于普通的服务器来说是承受不了的。<br>所以，我们存储这几十亿个元素，不能直接存值，我们应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。<br>这个东西我们就把它叫做位图，他是一个有序的数组，只有两个值，0 和 1。0 代表不存在，1 代表存在。<br>对于这个映射方法，我们有几个基本的要求:</p>
<ol>
<li>因为我们的值长度是不固定的，我希望不同长度的输入，可以得到固定长度的输出。</li>
<li>转换成下标的时候，我希望他在我的这个有序数组里面是分布均匀的，不然的话 全部挤到一对去了，我也没法判断到底哪个元素存了，哪个元素没存。</li>
</ol>
<p>这个就是哈希函数，比如 MD5、SHA-1 等等这些都是常见的哈希算法。</p>
<h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>如果发生了哈希碰撞，这个时候对于我们的容器存值肯定是有影响的，我们可以通过哪些方式去降低哈希碰撞的概率呢?<br>第一种就是扩大维数组的长度或者说位图容量。因为我们的函数是分布均匀的，所以，位图容量越大，在同一个位置发生哈希碰撞的概率就越小。<br>是不是位图容量越大越好呢?不管存多少个元素，都创建一个几万亿大小的位图， 可以吗？当然不行，因为越大的位图容量，意味着越多的内存消耗，所以我们要创建一个合适大小的位图容量。<br>第二种就是进行多次哈希计算。如果两个元素经过一次哈希计算，得到的相同下标的概率比较高，我可以不可以计 算多次呢? 原来我只用一个哈希函数，现在我对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小得多了。<br>同样的，我们能不能引入很多个哈希函数呢?比如都计算 100 次，都可以吗？当然也会有问题，第一个就是它会填满位图的更多空间，第二个是计算是需要消耗时间的。<br>所以总的来说，我们既要节省空间，又要很高的计算效率，就必须在位图容量和函数个数之间找到一个最佳的平衡。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>关于布隆过滤器可以参考我的另一篇博客：<br><a href="http://magicj.top/2019/12/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F/">什么是布隆过滤器？</a></p>

      
    </div>
    
    
    
    
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Chen Jun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://magicj.top/2019/12/01/深入理解Redis-实战篇/" title="深入理解Redis-实战篇">http://magicj.top/2019/12/01/深入理解Redis-实战篇/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/01/什么是布隆过滤器？/" rel="next" title="什么是布隆过滤器？">
                <i class="fa fa-chevron-left"></i> 什么是布隆过滤器？
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/06/深入MySQL-SQL执行流程/" rel="prev" title="深入MySQL-SQL执行流程">
                深入MySQL-SQL执行流程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/1.png" alt="Chen Jun">
            
              <p class="site-author-name" itemprop="name">Chen Jun</p>
              <p class="site-description motion-element" itemprop="description">行走在Java边缘，写点自己的博客技术文。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/magicCJ" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:13599462529@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/baidu_38083619" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis客户端"><span class="nav-number">1.</span> <span class="nav-text">Redis客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端通信原理"><span class="nav-number">1.1.</span> <span class="nav-text">客户端通信原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jedis"><span class="nav-number">1.2.</span> <span class="nav-text">Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.2.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-获取连接原理"><span class="nav-number">1.2.2.</span> <span class="nav-text">Sentinel 获取连接原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cluster-获取连接原理"><span class="nav-number">1.2.3.</span> <span class="nav-text">Cluster 获取连接原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pipeline"><span class="nav-number">1.2.4.</span> <span class="nav-text">pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#慢在哪里"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">慢在哪里?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pipeline-管道"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Pipeline 管道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis-实现分布式锁"><span class="nav-number">1.2.5.</span> <span class="nav-text">Jedis 实现分布式锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Luttece"><span class="nav-number">1.3.</span> <span class="nav-text">Luttece</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson"><span class="nav-number">1.4.</span> <span class="nav-text">Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本质"><span class="nav-number">1.4.1.</span> <span class="nav-text">本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现分布式锁"><span class="nav-number">1.4.3.</span> <span class="nav-text">实现分布式锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据一致性"><span class="nav-number">2.</span> <span class="nav-text">数据一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存使用场景"><span class="nav-number">2.1.</span> <span class="nav-text">缓存使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性问题的定义"><span class="nav-number">2.2.</span> <span class="nav-text">一致性问题的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方案选择"><span class="nav-number">2.3.</span> <span class="nav-text">方案选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-删除还是更新"><span class="nav-number">2.3.1.</span> <span class="nav-text">Redis:删除还是更新?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先更新数据库，再删除缓存"><span class="nav-number">2.3.2.</span> <span class="nav-text">先更新数据库，再删除缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先删除缓存，再更新数据库"><span class="nav-number">2.3.3.</span> <span class="nav-text">先删除缓存，再更新数据库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高并发问题"><span class="nav-number">3.</span> <span class="nav-text">高并发问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#热点数据发现"><span class="nav-number">3.1.</span> <span class="nav-text">热点数据发现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端"><span class="nav-number">3.1.1.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理层"><span class="nav-number">3.1.2.</span> <span class="nav-text">代理层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端"><span class="nav-number">3.1.3.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#机器层面"><span class="nav-number">3.1.4.</span> <span class="nav-text">机器层面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">3.2.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是缓存雪崩"><span class="nav-number">3.2.1.</span> <span class="nav-text">什么是缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存雪崩的解决方案"><span class="nav-number">3.2.2.</span> <span class="nav-text">缓存雪崩的解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透"><span class="nav-number">3.3.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存穿透何时发生"><span class="nav-number">3.3.1.</span> <span class="nav-text">缓存穿透何时发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#经典面试题"><span class="nav-number">3.3.2.</span> <span class="nav-text">经典面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希碰撞"><span class="nav-number">3.3.3.</span> <span class="nav-text">哈希碰撞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">3.3.4.</span> <span class="nav-text">布隆过滤器</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Jun</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">123.2k</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="http://cjblog-test.oss-cn-hangzhou.aliyuncs.com/blog/gitmint-default.css">
        <script src="http://cjblog-test.oss-cn-hangzhou.aliyuncs.com/blog/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: decodeURI(window.location.pathname), 
            owner: 'magicCJ',
            repo: 'magicCJ.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '99d7314e336092874e2fef5a888602f1a59860e0',
            
                client_id: 'dbb9d7e720b6135ad997'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  

</body>
</html>
